from loguru import logger

from utils.gas_checker import check_gas
from utils.helpers import retry
from .account import Account

from config import (
    BRIDGE_CONTRACTS,
    DEPOSIT_ABI,
    WITHDRAW_ABI,
    ORACLE_ABI,
    SCROLL_TOKENS,
    WETH_ABI
)


class Scroll(Account):
    def __init__(self, account_id: int, private_key: str, chain: str) -> None:
        super().__init__(account_id=account_id, private_key=private_key, chain=chain)

    async def deposit(
            self,
            min_amount: float,
            max_amount: float,
            decimal: int,
            all_amount: bool,
            min_percent: int,
            max_percent: int
    ):
        try:
            amount_wei, amount, balance = await self.get_amount(
                "ETH",
                min_amount,
                max_amount,
                decimal,
                all_amount,
                min_percent,
                max_percent
            )

            logger.info(f"[{self.account_id}][{self.address}] Bridge to Scroll | {amount} ETH")

            contract = self.get_contract(BRIDGE_CONTRACTS["deposit"], DEPOSIT_ABI)
            contract_oracle = self.get_contract(BRIDGE_CONTRACTS["oracle"], ORACLE_ABI)

            fee = await contract_oracle.functions.estimateCrossDomainMessageFee(168000).call()

            tx_data = await self.get_tx_data(amount_wei + fee, False)

            transaction = await contract.functions.depositETH(
                amount_wei,
                168000,
            ).build_transaction(tx_data)

            signed_txn = await self.sign(transaction)

            txn_hash = await self.send_raw_transaction(signed_txn)

            await self.wait_until_tx_finished(txn_hash.hex())
            return True
        except Exception as e:
            logger.error(
                f"[{self.account_id}][{self.address}] Bridge to Scroll Error | {e}"
            )

        return False

    async def withdraw(
            self,
            min_amount: float,
            max_amount: float,
            decimal: int,
            all_amount: bool,
            min_percent: int,
            max_percent: int
    ):
        try:
            amount_wei, amount, balance = await self.get_amount(
                "ETH",
                min_amount,
                max_amount,
                decimal,
                all_amount,
                min_percent,
                max_percent
            )

            logger.info(f"[{self.account_id}][{self.address}] Bridge from Scroll | {amount} ETH")

            contract = self.get_contract(BRIDGE_CONTRACTS["withdraw"], WITHDRAW_ABI)

            tx_data = await self.get_tx_data(amount_wei)

            transaction = await contract.functions.withdrawETH(
                amount_wei,
                0
            ).build_transaction(tx_data)

            signed_txn = await self.sign(transaction)

            txn_hash = await self.send_raw_transaction(signed_txn)

            await self.wait_until_tx_finished(txn_hash.hex())
            return True
        except Exception as e:
            logger.error(
                f"[{self.account_id}][{self.address}] Bridge from Scroll Error | {e}"
            )

        return False


    async def wrap_eth(
            self,
            min_amount: float,
            max_amount: float,
            decimal: int,
            all_amount: bool,
            min_percent: int,
            max_percent: int
    ):
        try:
            amount_wei, amount, balance = await self.get_amount(
                "ETH",
                min_amount,
                max_amount,
                decimal,
                all_amount,
                min_percent,
                max_percent
            )

            weth_contract = self.get_contract(SCROLL_TOKENS["WETH"], WETH_ABI)

            logger.info(f"[{self.account_id}][{self.address}] Wrap {amount} ETH")

            tx_data = await self.get_tx_data(amount_wei)

            transaction = await weth_contract.functions.deposit().build_transaction(tx_data)

            signed_txn = await self.sign(transaction)

            txn_hash = await self.send_raw_transaction(signed_txn)

            await self.wait_until_tx_finished(txn_hash.hex())
            return True
        except Exception as e:
            logger.error(
                f"[{self.account_id}][{self.address}] Wrap Error | {e}"
            )

        return False

    async def unwrap_eth(
            self,
            min_amount: float,
            max_amount: float,
            decimal: int,
            all_amount: bool,
            min_percent: int,
            max_percent: int
    ):
        try:
            amount_wei, amount, balance = await self.get_amount(
                "WETH",
                min_amount,
                max_amount,
                decimal,
                all_amount,
                min_percent,
                max_percent
            )

            weth_contract = self.get_contract(SCROLL_TOKENS["WETH"], WETH_ABI)

            logger.info(f"[{self.account_id}][{self.address}] Unwrap {amount} ETH")

            tx_data = await self.get_tx_data()

            transaction = await weth_contract.functions.withdraw(amount_wei).build_transaction(tx_data)

            signed_txn = await self.sign(transaction)

            txn_hash = await self.send_raw_transaction(signed_txn)

            await self.wait_until_tx_finished(txn_hash.hex())
            return True
        except Exception as e:
            logger.error(
                f"[{self.account_id}][{self.address}] Unwrap Error | {e}"
            )

        return False

